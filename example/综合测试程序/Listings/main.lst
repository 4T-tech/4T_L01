C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "stc12.h"
   2          /* 综合测试程序包括 
   3          1.串口播报和注册码
   4          2.流水灯
   5          3.18b20 1602显示
   6          4.按键切换功能
   7          5.E2上电次数
   8          6.adc 数码管显示
   9          7.蜂鸣器
  10          
  11          */ 
  12          
  13          #include "stdio.h"
  14          #include "string.h"
  15          #include "iic.h"
  16          #include "LCD1602.h"
  17          #include "Uart.h"
  18          #include "delay.h"
  19          #include "DS18B20.h"
  20          
  21          /******设置按键******/
  22          //sbit LED_CHOICE = P2^3;
  23          //sbit SEG_CHOICE = P2^4;
  24          sbit beep = P4^0;
  25          sbit S1 = P3^0;
  26          sbit S2 = P3^1;
  27          sbit S3 = P3^2;
  28          sbit S4 = P3^3;
  29          /********************/
  30          
  31          /******设置ADC******/
  32          sbit CS=P4^5;
  33          sbit CLK=P4^1;
  34          sbit DOUT=P4^3;
  35          //const unsigned char code SegCode[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};//共阴极段码0~9
  36          //const unsigned char code BitCode[]={0x08,0x04,0x02,0x01}; //位码:P0口“1”有效
  37          unsigned char DispBuf_AD[4]={0,0,0,0};                //显示缓冲区
  38          float Volt;
  39          static unsigned char key_flag = 0;
  40          /********************/
  41          
  42          unsigned char digits[4];
  43          unsigned char boot_times;
  44          
  45          
  46          void uart_init();
  47          void uart_printf(unsigned char *tdata);
  48          void led_running();
  49          void seg_display(unsigned char *tdata,unsigned char longth);
  50          void write_AT24C02(unsigned char addr, unsigned char dat);
  51          void AT_Buff();
  52          void DisplayBootTimes();
  53          void rtc_init();
  54          void adc_init();
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 2   

  55          void buzz_running();
  56          void PlayNote(unsigned int frequency, unsigned int duration);
  57          void key_check();
  58          
  59          
  60          /******串口部分******/
  61          /*串口初始化*/
  62          //void uart_init()
  63          //{
  64          //  TMOD=0x20;        //定时器T1工作于方式2
  65          //  TL1=0xfd;         //波特率为9600bps
  66          //  TH1=0xfd;
  67          //  TR1=1;
  68          //  EA=1;
  69          //  ES=1;
  70          //  SCON=0x50;        //定义串行口工作于方式1
  71          //}
  72          /*上报版本号,版本号还不知道怎么获取*/
  73          void uart_printf(unsigned char *tdata)
  74          {
  75   1          unsigned char i;
  76   1          unsigned char printf_data[33] = "$TEALQL$000000000000000000000000$"; /*$TEALQL$XXXXXXXXXXXXXXXXXXXXXX$
             -*/
  77   1          unsigned char error_pattern_1[17] = "0000000000000000";
  78   1          unsigned char error_pattern_2[17] = "FFFFFFFFFFFFFFFF";
  79   1          unsigned char error_message[] = "ERROR";
  80   1      
  81   1          // 检查tdata是否为错误模式之一
  82   1          if (memcmp(tdata, error_pattern_1, 16) == 0 || 
  83   1              memcmp(tdata, error_pattern_2, 16) == 0) 
  84   1          {
  85   2              // 如果是错误模式，则发送“ERROR”
  86   2              for (i = 0; i<5; i++) { // -1以忽略字符串结束符'\0'
  87   3                  SBUF = error_message[i]; // 发送第i个字符
  88   3                  while (TI == 0);         // 查询等待发送是否完成
  89   3                  TI = 0;                  // 发送完成，TI由软件清0
  90   3              }
  91   2              return; // 结束函数，不继续发送原始数据
  92   2          }
  93   1      
  94   1          // 正常情况下，将tdata复制到printf_data并发送
  95   1          memcpy(printf_data + 8, tdata, 16);
  96   1      
  97   1          // 发送数据包
  98   1          for (i=0; i<33; i++)
  99   1          {
 100   2              SBUF = printf_data[i]; // 发送第i个数据
 101   2              while (TI == 0);       // 查询等待发送是否完成
 102   2              TI = 0;                // 发送完成，TI由软件清0
 103   2          }
 104   1      }
 105          //void uart_printf(unsigned char *tdata)
 106          //{
 107          //  unsigned char i;
 108          //  unsigned char printf_data[33] = "$TEALQL$000000000000000000000000$";  /*$TEALQL$XXXXXXXXXXXXXXXXXXXXXX$*
             -/
 109          //  memcpy(printf_data+8,tdata,16);
 110          //  for (i=0;i<33;i++)
 111          //  {
 112          //    SBUF=printf_data[i];      // 发送第i个数据
 113          //    while(TI==0);     // 查询等待发送是否完成
 114          //    TI=0;       // 发送完成，TI由软件清0
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 3   

 115          //  }
 116          //}
 117          
 118          /******流水灯******/
 119          void led_running()
 120          {
 121   1        /*快速过几轮,需要开关在LED上面*/
 122   1        unsigned char j=0;
 123   1        while(j<3)
 124   1        {
 125   2          unsigned char aa,i;
 126   2          aa=0x01;
 127   2          for(i=0;i<8;i++)
 128   2          {
 129   3            P0=~aa;
 130   3            delay(500);
 131   3            aa<<=1;
 132   3          }   
 133   2          j++;
 134   2        }
 135   1          P0=0x00;
 136   1          delay(1000);
 137   1          P0=0xff;
 138   1          
 139   1      }
 140          
 141          
 142          /******数码管显示******/
 143          void seg_display(unsigned char *tdata,unsigned char longth)
 144          {
 145   1        unsigned char seg_data[10] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};/*字码表*/
 146   1        unsigned char i,w;                                
 147   1        P24 = 1;  
 148   1        w=0xFE;             //位选码初值为0xfe
 149   1        for(i=0;i<longth;i++)
 150   1        {
 151   2          P0=0xff;          //关显示，共阳极数码管0xff熄灭
 152   2          P24 = 0;
 153   2          P0=~w;            //位选码送位选端P0口
 154   2          P24 = 1;
 155   2          w=_crol_(w,1);    //位选码左移一位，选中下一位LED
 156   2          P0=seg_data[ tdata[i] ] ;        //显示字型码并送P0口
 157   2          delay(10);        //延时
 158   2        }
 159   1      }
 160          
 161          /******eeprom******/
 162          void write_AT24C02(unsigned char addr, unsigned char dat)
 163          {
 164   1          // 发送起始信号
 165   1          I2C_Start();
 166   1          
 167   1          // 发送设备地址加上写操作位
 168   1          I2C_send_byte(AT24C02_ADDR | 0x00); // AT24C02的写地址是基础地址加上0
 169   1          if (!Test_ACK())
 170   1          {
 171   2              // 如果没有收到应答，则退出
 172   2              I2C_Stop();
 173   2              return;
 174   2          }
 175   1          
 176   1          // 发送内存地址
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 4   

 177   1          I2C_send_byte(addr);
 178   1          if (!Test_ACK())
 179   1          {
 180   2              // 如果没有收到应答，则退出
 181   2              I2C_Stop();
 182   2              return;
 183   2          }
 184   1          
 185   1          // 发送要写入的数据
 186   1          I2C_send_byte(dat);
 187   1          if (!Test_ACK())
 188   1          {
 189   2              // 如果没有收到应答，则退出
 190   2              I2C_Stop();
 191   2              return;
 192   2          }
 193   1          
 194   1          // 发送停止信号
 195   1          I2C_Stop();
 196   1          
 197   1          // 等待EEPROM完成写入操作
 198   1          delay(10); // 根据具体需求调整延迟时间
 199   1      }
 200          unsigned char read_AT24C02(unsigned char addr)
 201          {
 202   1        unsigned char dat;
 203   1        I2C_Start();
 204   1        I2C_send_byte(AT24C02_ADDR+0);
 205   1        if (!Test_ACK())
 206   1        {
 207   2          return(0);
 208   2        }
 209   1        I2C_send_byte(addr);
 210   1        Master_ACK(0);
 211   1        I2C_Start();
 212   1        I2C_send_byte(AT24C02_ADDR+1);
 213   1        if (!Test_ACK())
 214   1        {
 215   2          return(0);
 216   2        }
 217   1        dat = I2C_read_byte();
 218   1        Master_ACK(0);
 219   1        I2C_Stop();
 220   1        return(dat);
 221   1      }
 222          /*返回开机次数*/
 223          unsigned char at24c02_init()
 224          {
 225   1        /*用数码管显示开机次数，模拟i2c另外文件*/
 226   1        unsigned char times;
 227   1        times = read_AT24C02(254);
 228   1        //printf("times=%bu\n",times);
 229   1        if(times < 255 )
 230   1        {
 231   2            times=times+1;
 232   2            write_AT24C02(254,times);
 233   2            delay(130);
 234   2        //  printf("times2=%bu\n",times);
 235   2        }
 236   1        else
 237   1        {
 238   2          times = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 5   

 239   2          write_AT24C02(254,times);
 240   2          delay(130);
 241   2          
 242   2        }
 243   1        //printf("times3=%bu\n",times);
 244   1        return times;
 245   1        
 246   1      }
 247          
 248          void AT_Buff()        //转换值送显示缓冲区(BCD码)
 249          {
 250   1        digits[3]= 0;
 251   1        digits[2]= boot_times/100;  //百位
 252   1        digits[1]= (boot_times/10)%10;  //十位
 253   1        digits[0]= boot_times%10;     //个位
 254   1      }
 255          
 256          void DisplayBootTimes()
 257          {
 258   1        unsigned char i;
 259   1        SEG_CHOICE=1;
 260   1        P0=0xff;
 261   1        LED_CHOICE=1;
 262   1        LED_CHOICE=0;
 263   1        for(i=0;i<4;i++)
 264   1        {
 265   2          SEG_CHOICE=1;
 266   2          P0=SegCode[digits[i]];
 267   2          SEG_CHOICE=0;
 268   2          P0=BitCode[i];
 269   2          delay_ADC(10);
 270   2        }
 271   1        SEG_CHOICE = 1;
 272   1        P0 = 0xff;
 273   1        SEG_CHOICE = 0;
 274   1      }
 275          
 276          
 277          
 278          
 279          
 280          
 281          /******模数转换******/
 282          unsigned int TLC549_ADC(void)
 283          {
 284   1        unsigned int i,temp=0;
 285   1        CS=1;
 286   1        CLK =0;
 287   1        CS=0;
 288   1        delay_us(20);
 289   1        for(i=0;i<8;i++)
 290   1        {
 291   2          temp=temp<<1;
 292   2          if (DOUT == 1) temp|=0x01;
 293   2          CLK=1;
 294   2          delay_us(10);
 295   2          CLK =0;
 296   2          delay_us(10);
 297   2        }
 298   1        
 299   1        CS =1;
 300   1        delay_us(100);
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 6   

 301   1        //printf("%d adc \r\n",temp);
 302   1        return (temp);
 303   1      }
 304          void AD_Buff()        //AD转换值送显示缓冲区(BCD码)
 305          {
 306   1        DispBuf_AD[3]= (unsigned int)Volt /1000;    //千位
 307   1        DispBuf_AD[2]= ((unsigned int)Volt/100)%10; //百位
 308   1        DispBuf_AD[1]= ((unsigned int)Volt /10)%10; //十位
 309   1        DispBuf_AD[0]= (unsigned int)Volt %10;      //个位
 310   1      }
 311          
 312          void adc_display()
 313          {
 314   1        unsigned char i;
 315   1        SEG_CHOICE=1;
 316   1        P0=0xff;
 317   1        LED_CHOICE=1;
 318   1        LED_CHOICE=0;
 319   1        for(i=0;i<4;i++)
 320   1        {
 321   2          if(i==3)
 322   2          {
 323   3            SEG_CHOICE=1;
 324   3            P0=SegCode[DispBuf_AD[i]]&0x7f;
 325   3            SEG_CHOICE=0;
 326   3            P0=BitCode[i];
 327   3            delay(10);
 328   3          }
 329   2          else
 330   2          {
 331   3            SEG_CHOICE=1;
 332   3            P0=SegCode[DispBuf_AD[i]];
 333   3            SEG_CHOICE=0;
 334   3            P0=BitCode[i];
 335   3            delay(10);
 336   3          }
 337   2        }
 338   1        SEG_CHOICE = 1;
 339   1        P0 = 0xff;
 340   1        SEG_CHOICE = 0;
 341   1      }
 342          
 343          
 344          
 345          /******蜂鸣器******/
 346          void Delay_B(unsigned int time)
 347          {
 348   1          unsigned int i;
 349   1          for (i = 0; i < time; i++);
 350   1      }
 351          
 352          void buzz_running()
 353          {
 354   1          beep=0;
 355   1          Delay_B(30);
 356   1          beep=1;
 357   1          Delay_B(30);
 358   1      }
 359          
 360          void key_check(void)
 361          {
 362   1          // 检查S1按键
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 7   

 363   1          if (S1 == 0) {
 364   2              delay(10); // 延时去抖动
 365   2              if (S1 == 0 && key_flag != 1) {
 366   3                  key_flag = 1; // 设置S1标志位
 367   3              }
 368   2          }
 369   1      
 370   1          // 检查S2按键
 371   1          if (S2 == 0) {
 372   2              delay(10); // 延时去抖动
 373   2              if (S2 == 0 && key_flag != 2) {
 374   3                  key_flag = 2; // 设置S2标志位
 375   3              }
 376   2          }
 377   1      
 378   1          // 检查S3按键
 379   1          if (S3 == 0) {
 380   2              delay(10); // 延时去抖动
 381   2              if (S3 == 0 && key_flag != 3) {
 382   3                  key_flag = 3; // 设置S3标志位
 383   3              }
 384   2          }
 385   1      
 386   1          // 检查S4按键
 387   1          if (S4 == 0) {
 388   2              delay(10); // 延时去抖动
 389   2              if (S4 == 0 && key_flag != 4) {
 390   3                  key_flag = 4; // 设置S4标志位
 391   3              }
 392   2          }
 393   1      
 394   1          // 如果按键释放，则清除标志位
 395   1          if (S1 && key_flag == 1) key_flag = 0;
 396   1          if (S2 && key_flag == 2) key_flag = 0;
 397   1          if (S3 && key_flag == 3) key_flag = 0;
 398   1          if (S4 && key_flag == 4) key_flag = 0;
 399   1      }
 400          
 401          void process_key_flags(void)
 402          {
 403   1          switch(key_flag) {
 404   2              case 1: // S1按键按下
 405   2              {
 406   3                  unsigned char i = 0;
 407   3                  unsigned int ad;
 408   3                  while(S4 != 0) {
 409   4                      i++;
 410   4                      if(i == 20) {
 411   5                          ad = TLC549_ADC();
 412   5                          i = 0;
 413   5                      }
 414   4                      Volt = 5.0 * ad / 255.0 * 1000.0;
 415   4                      AD_Buff();
 416   4                      adc_display();
 417   4                  }
 418   3                  break;
 419   3              }
 420   2              case 2: // S2按键按下
 421   2              {
 422   3                  while(S4 != 0) {
 423   4                      Read_Temp();
 424   4                      Temp_to_Buff();
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 8   

 425   4                      Display();
 426   4                  }
 427   3                  break;
 428   3              }
 429   2              case 3: // S3按键按下
 430   2              {
 431   3                  buzz_running();
 432   3                  break;
 433   3              }
 434   2              case 4: // S4按键按下
 435   2              {
 436   3                  // 这里添加S4按键的功能实现
 437   3                  break;
 438   3              }
 439   2              default:
 440   2                  break;
 441   2          }
 442   1      }
 443          
 444          void main()
 445          { 
 446   1        unsigned char i,temp;
 447   1        unsigned char j=0;
 448   1        unsigned char ROM[16]={8,8,8,8,8,8,8,8};
 449   1        CS = 1;
 450   1        SEG_CHOICE=0;
 451   1        LED_CHOICE=1; 
 452   1        led_running();
 453   1        LED_CHOICE=0;
 454   1        P4SW|=0xFF;
 455   1        UART_Init();
 456   1        CS = 0;
 457   1        DQ = 1;
 458   1      
 459   1        i = 100;
 460   1        while(i--) seg_display(ROM,8);
 461   1        
 462   1        
 463   1        boot_times = at24c02_init();
 464   1      //  printf("boot_times=%bu\n",boot_times);
 465   1        AT_Buff();
 466   1      //  DisplayBootTimes();
 467   1        
 468   1        while (S1!=0&&S2!=0&&S3!=0&&S4!=0)
 469   1        {
 470   2          DisplayBootTimes();
 471   2        }
 472   1        CS = 1;
 473   1        DQ = 0;
 474   1        
 475   1      ///******1602液晶显示******/
 476   1      //  init_1602();
 477   1      //  dsp_string(0,"  Welcome...",12);
 478   1      //  dsp_string(1," www.gxct.net",13);
 479   1      ///******1602液晶显示******/
 480   1      
 481   1        while(1)
 482   1        {
 483   2          key_check();
 484   2          process_key_flags();
 485   2        }
 486   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              09/26/2025 11:52:30 PAGE 9   

*** WARNING C280 IN LINE 446 OF main.c: 'temp': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1907    ----
   CONSTANT SIZE    =    113    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     28     145
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
