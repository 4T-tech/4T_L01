C51 COMPILER V9.60.7.0   IIC                                                               09/26/2025 11:52:30 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN .\Objects\iic.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE iic.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\iic.lst) TABS(2) OBJECT(.\Objects\iic.obj)

line level    source

   1          //#include "iic.h"
   2          
   3          //#define delay_time  5
   4          
   5          //static void iic_delay(unsigned char n)
   6          //{
   7          //  do
   8          //  {
   9          //    _nop_();_nop_();_nop_();_nop_();_nop_();
  10          //    _nop_();_nop_();_nop_();_nop_();_nop_();
  11          //    _nop_();_nop_();_nop_();_nop_();_nop_();    
  12          //  }
  13          //  while(n--);       
  14          //}
  15          
  16          ////
  17          //void iic_start(void)
  18          //{
  19          //  sda = 1;
  20          //  scl = 1;
  21          //  iic_delay(delay_time);
  22          //  sda = 0;
  23          //  iic_delay(delay_time);
  24          //  scl = 0;    
  25          //}
  26          
  27          ////
  28          //void iic_stop(void)
  29          //{
  30          //  sda = 0;
  31          //  scl = 1;
  32          //  iic_delay(delay_time);
  33          //  sda = 1;
  34          //  iic_delay(delay_time);
  35          //}
  36          
  37          ////
  38          //void iic_send_byte(unsigned char byt)
  39          //{
  40          //  unsigned char i;
  41          //  
  42          //  for(i=0; i<8; i++)
  43          //  {
  44          //    scl = 0;
  45          //    iic_delay(delay_time);
  46          //    if(byt & 0x80)
  47          //    {
  48          //      sda = 1;
  49          //    }
  50          //    else{
  51          //      sda = 0;
  52          //    }
  53          //    iic_delay(delay_time);
  54          //    scl = 1;
C51 COMPILER V9.60.7.0   IIC                                                               09/26/2025 11:52:30 PAGE 2   

  55          //    byt <<= 1;
  56          //    iic_delay(delay_time);
  57          //  }
  58          //  scl = 0;  
  59          //}
  60          
  61          ////
  62          //unsigned char iic_wait_ack(void)
  63          //{
  64          //  unsigned char ack_bit;
  65          //  
  66          //  scl = 1;
  67          //  iic_delay(delay_time);
  68          //  ack_bit = sda; 
  69          //  scl = 0;
  70          //  iic_delay(delay_time);
  71          //  
  72          //  return ack_bit;
  73          //}
  74          
  75          ////
  76          //unsigned char iic_receive_byte(void)
  77          //{
  78          //  unsigned char da;
  79          //  unsigned char i;
  80          //  for(i=0;i<8;i++){   
  81          //    scl = 1;
  82          //    iic_delay(delay_time);
  83          //    da <<= 1;
  84          //    if(sda) 
  85          //      da |= 0x01;
  86          //    scl = 0;
  87          //    iic_delay(delay_time);
  88          //  }
  89          //  return da;    
  90          //}
  91          
  92          ////
  93          //void iic_send_ack(unsigned char ack_bit)
  94          //{
  95          //  scl = 0;
  96          //  sda = ack_bit; 
  97          //  iic_delay(delay_time);
  98          //  scl = 1;
  99          //  iic_delay(delay_time);
 100          //  scl = 0; 
 101          //  sda = 1;
 102          //  iic_delay(delay_time);
 103          //}
 104          
 105          
 106          
 107          
 108          #include "iic.h"
 109          
 110          
 111          #define uchar unsigned char
 112          #define uint unsigned  int
 113          #define AT24C02_ADDR  0xa0  //AT24C02地址
 114          
 115          
 116          ////基于STC12单片机1us延时函数
C51 COMPILER V9.60.7.0   IIC                                                               09/26/2025 11:52:30 PAGE 3   

 117          ////函数说明：内部调用
 118          //static void Delaym1us()
 119          //{
 120          //  _nop_();
 121          //}
 122          
 123          ////基于STC12单片机us延时函数
 124          ////函数说明：外部调用
 125          //void Delay_us(uint time)
 126          //{
 127          //  int i;
 128          //  for(i=0; i<time; i++)
 129          //  {
 130          //    Delaym1us();
 131          //  }
 132          //}
 133          
 134          ///*5us延时*/
 135          //void delay_5us()  
 136          //{
 137          //  Delay_us(5);
 138          //}
 139          
 140          ///*1Ms延时*/
 141          //void delay(uint z)
 142          //{
 143          //  uint x,y;
 144          //  for(x = z; x > 0; x--)
 145          //    for(y = 114; y > 0 ; y--);
 146          //}
 147          
 148          /*I2C初始化*/
 149          void I2C_init() 
 150          {
 151   1        sda = 1;
 152   1        _nop_();
 153   1        scl = 1;
 154   1        _nop_();
 155   1      }
 156          
 157          /*I2C起始信号*/
 158          void I2C_Start()  
 159          {
 160   1        scl = 1;
 161   1        _nop_();
 162   1        sda = 1;
 163   1        delay_5us();
 164   1        sda = 0;
 165   1        delay_5us();
 166   1      }
 167          
 168          /*I2C终止信号*/
 169          void I2C_Stop()
 170          {
 171   1        sda = 0;
 172   1        _nop_();
 173   1        scl = 1;
 174   1        delay_5us();
 175   1        sda = 1;
 176   1        delay_5us();
 177   1      }
 178          
C51 COMPILER V9.60.7.0   IIC                                                               09/26/2025 11:52:30 PAGE 4   

 179          /*主机发送应答*/
 180          void Master_ACK(bit i)    
 181          {
 182   1        scl = 0; // 拉低时钟总线允许sda数据总线上的数据变化
 183   1        _nop_(); // 让总线稳定
 184   1        if (i)   //如果i = 1 那么拉低数据总线 表示主机应答
 185   1        {
 186   2          sda = 0;
 187   2        }
 188   1        else   
 189   1        {
 190   2          sda = 1;   //发送非应答
 191   2        }
 192   1        _nop_();//让总线稳定
 193   1        scl = 1;//拉高时钟总线 让从机从sda线上读走 主机的应答信号
 194   1        delay_5us();
 195   1        scl = 0;//拉低时钟总线， 占用总线继续通信
 196   1        _nop_();
 197   1        sda = 1;//释放sda数据总线。
 198   1        _nop_();
 199   1      }
 200          
 201          /*检测从机应答*/
 202          bit Test_ACK()
 203          {
 204   1        scl = 1;
 205   1        delay_5us();
 206   1        if (sda)
 207   1        {
 208   2          scl = 0;
 209   2          _nop_();
 210   2          I2C_Stop();
 211   2          return(0);
 212   2        }
 213   1        else
 214   1        {
 215   2          scl = 0;
 216   2          _nop_();
 217   2          return(1);
 218   2        }
 219   1      }
 220          
 221          /*发送一个字节*/
 222          void I2C_send_byte(uchar byte)
 223          {
 224   1        uchar i;
 225   1        for(i = 0 ; i < 8 ; i++)
 226   1        {
 227   2          scl = 0;
 228   2          _nop_();
 229   2          if (byte & 0x80)
 230   2          {       
 231   3            sda = 1;  
 232   3            _nop_();           
 233   3          }       
 234   2          else
 235   2          {
 236   3            sda = 0;
 237   3            _nop_();
 238   3          }
 239   2          scl = 1;
 240   2          _nop_();
C51 COMPILER V9.60.7.0   IIC                                                               09/26/2025 11:52:30 PAGE 5   

 241   2          byte <<= 1; // 0101 0100B 
 242   2        }
 243   1        scl = 0;
 244   1        _nop_();
 245   1        sda = 1;
 246   1        _nop_();
 247   1      }
 248          
 249          
 250          /*I2C 读一字节*/
 251          uchar I2C_read_byte()
 252          {
 253   1        uchar dat,i;
 254   1        scl = 0;
 255   1        _nop_();
 256   1        sda = 1;
 257   1        _nop_();
 258   1        for(i = 0 ; i < 8 ; i++)
 259   1        {
 260   2          scl = 1;
 261   2          _nop_();
 262   2          if (sda)          
 263   2          {
 264   3             dat |= 0x01; //
 265   3          }
 266   2          else
 267   2          {
 268   3            dat &=  0xfe; //1111 1110
 269   3          }
 270   2          _nop_();
 271   2          scl = 0 ;
 272   2          _nop_();
 273   2          if(i < 7)
 274   2          {
 275   3            dat = dat << 1; 
 276   3          }
 277   2        }
 278   1        return(dat);
 279   1      }
 280          
 281          /*I2C发送数据*/
 282          bit I2C_TransmitData(uchar ADDR, DAT)
 283          {
 284   1        I2C_Start();
 285   1        I2C_send_byte(AT24C02_ADDR+0);
 286   1        if (!Test_ACK())
 287   1        {
 288   2          return(0);
 289   2        }
 290   1        I2C_send_byte(ADDR); 
 291   1        if (!Test_ACK())
 292   1        {
 293   2          return(0);
 294   2        }
 295   1        I2C_send_byte(DAT);
 296   1        if (!Test_ACK())
 297   1        {
 298   2          return(0);
 299   2        }
 300   1        I2C_Stop();
 301   1        return(1);  
 302   1      }
C51 COMPILER V9.60.7.0   IIC                                                               09/26/2025 11:52:30 PAGE 6   

 303          
 304          /*I2C接收数据*/
 305          uchar I2C_ReceiveData(uchar ADDR)
 306          {
 307   1        uchar DAT;
 308   1        I2C_Start();
 309   1        I2C_send_byte(AT24C02_ADDR+0);
 310   1        if (!Test_ACK())
 311   1        {
 312   2          return(0);
 313   2        }
 314   1        I2C_send_byte(ADDR);
 315   1        Master_ACK(0);
 316   1        I2C_Start();
 317   1        I2C_send_byte(AT24C02_ADDR+1);
 318   1        if (!Test_ACK())
 319   1        {
 320   2          return(0);
 321   2        }
 322   1        DAT = I2C_read_byte();
 323   1        Master_ACK(0);
 324   1        I2C_Stop();
 325   1        return(DAT);  
 326   1      }
 327          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    277    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----       5
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
