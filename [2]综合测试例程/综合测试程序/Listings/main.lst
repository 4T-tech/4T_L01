C51 COMPILER V9.60.7.0   MAIN                                                              09/28/2025 15:09:35 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT WARNINGLEVEL(0) OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          
   2          #include "main.h"
   3          
   4          /*数码管显示相关*/
   5          unsigned char SegCode[10]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};//共阴极段码0~9
   6          unsigned char BitCode[4]={0x08,0x04,0x02,0x01}; //位码:P0口“1”有效
   7          
   8          /*按键定义与蜂鸣器定义*/
   9          sbit beep = P4^0;
  10          sbit S1 = P3^0;
  11          sbit S2 = P3^1;
  12          sbit S3 = P3^2;
  13          sbit S4 = P3^3;
  14          static unsigned char key_flag = 0; //按键标志
  15          
  16          /*ADC相关定义以及AD显示数目缓冲区*/
  17          sbit CS=P4^5;
  18          sbit CLK=P4^1;
  19          sbit DOUT=P4^3;
  20          unsigned char DispBuf_AD[4]={0,0,0,0};                //显示缓冲区  
  21          float Volt;               //电压值
  22          unsigned char digits[4];  //BCD码
  23          
  24          /*eeprom*/
  25          unsigned char boot_times; //商店次数
  26          
  27          
  28          void led_running();
  29          void seg_display(unsigned char *tdata,unsigned char longth);
  30          void AT_Buff();
  31          void DisplayBootTimes();
  32          void key_check();
  33          void process_key_flags(void);
  34          unsigned char at24c02_init();
  35          
  36          void main()
  37          { 
  38   1        unsigned char i,temp;
  39   1        unsigned char j=0;
  40   1        unsigned char ROM[16]={8,8,8,8,8,8,8,8};
  41   1        CS = 1;
  42   1        SEG_CHOICE=0;
  43   1        LED_CHOICE=1; 
  44   1        led_running();
  45   1        LED_CHOICE=0;
  46   1        P4SW|=0xFF;
  47   1        UART_Init();
  48   1        CS = 0;
  49   1        DQ = 1;
  50   1      
  51   1        i = 100;
  52   1        while(i--) seg_display(ROM,8);
  53   1        
  54   1        boot_times = at24c02_init();
C51 COMPILER V9.60.7.0   MAIN                                                              09/28/2025 15:09:35 PAGE 2   

  55   1        AT_Buff();
  56   1        DisplayBootTimes();
  57   1      
  58   1        CS = 1;
  59   1        DQ = 0;
  60   1        
  61   1      ///******1602液晶显示******/
  62   1      //  init_1602();
  63   1      //  dsp_string(0,"  Welcome...",12);
  64   1      //  dsp_string(1," www.gxct.net",13);
  65   1      ///******1602液晶显示******/
  66   1      
  67   1        while(1)
  68   1        {
  69   2          key_check();
  70   2          process_key_flags();
  71   2        }
  72   1      }
  73          /********************************************************************/
  74          
  75          /******流水灯******/
  76          void led_running()
  77          {
  78   1        /*快速过几轮,需要开关在LED上面*/
  79   1        unsigned char j=0;
  80   1        while(j<3)
  81   1        {
  82   2          unsigned char aa,i;
  83   2          aa=0x01;
  84   2          for(i=0;i<8;i++)
  85   2          {
  86   3            P0=~aa;
  87   3            delay(500);
  88   3            aa<<=1;
  89   3          }   
  90   2          j++;
  91   2        }
  92   1          P0=0x00;
  93   1          delay(1000);
  94   1          P0=0xff;
  95   1          
  96   1      }
  97          
  98          /******数码管显示******/
  99          void seg_display(unsigned char *tdata,unsigned char longth)
 100          {
 101   1        unsigned char seg_data[10] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};/*字码表*/
 102   1        unsigned char i,w;                                
 103   1        P24 = 1;  
 104   1        w=0xFE;             //位选码初值为0xfe
 105   1        for(i=0;i<longth;i++)
 106   1        {
 107   2          P0=0xff;          //关显示，共阳极数码管0xff熄灭
 108   2          P24 = 0;
 109   2          P0=~w;            //位选码送位选端P0口
 110   2          P24 = 1;
 111   2          w=_crol_(w,1);    //位选码左移一位，选中下一位LED
 112   2          P0=seg_data[ tdata[i] ] ;        //显示字型码并送P0口
 113   2          delay(10);        //延时
 114   2        }
 115   1      }
 116          
C51 COMPILER V9.60.7.0   MAIN                                                              09/28/2025 15:09:35 PAGE 3   

 117          /******eeprom******/
 118          void write_AT24C02(unsigned char addr, unsigned char dat)
 119          {
 120   1          // 发送起始信号
 121   1          I2C_Start();
 122   1          
 123   1          // 发送设备地址加上写操作位
 124   1          I2C_send_byte(AT24C02_ADDR | 0x00); // AT24C02的写地址是基础地址加上0
 125   1          if (!Test_ACK())
 126   1          {
 127   2              // 如果没有收到应答，则退出
 128   2              I2C_Stop();
 129   2              return;
 130   2          }
 131   1          
 132   1          // 发送内存地址
 133   1          I2C_send_byte(addr);
 134   1          if (!Test_ACK())
 135   1          {
 136   2              // 如果没有收到应答，则退出
 137   2              I2C_Stop();
 138   2              return;
 139   2          }
 140   1          
 141   1          // 发送要写入的数据
 142   1          I2C_send_byte(dat);
 143   1          if (!Test_ACK())
 144   1          {
 145   2              // 如果没有收到应答，则退出
 146   2              I2C_Stop();
 147   2              return;
 148   2          }
 149   1          
 150   1          // 发送停止信号
 151   1          I2C_Stop();
 152   1          
 153   1          // 等待EEPROM完成写入操作
 154   1          delay(10); // 根据具体需求调整延迟时间
 155   1      }
 156          unsigned char read_AT24C02(unsigned char addr)
 157          {
 158   1        unsigned char dat;
 159   1        I2C_Start();
 160   1        I2C_send_byte(AT24C02_ADDR+0);
 161   1        if (!Test_ACK())
 162   1        {
 163   2          return(0);
 164   2        }
 165   1        I2C_send_byte(addr);
 166   1        Master_ACK(0);
 167   1        I2C_Start();
 168   1        I2C_send_byte(AT24C02_ADDR+1);
 169   1        if (!Test_ACK())
 170   1        {
 171   2          return(0);
 172   2        }
 173   1        dat = I2C_read_byte();
 174   1        Master_ACK(0);
 175   1        I2C_Stop();
 176   1        return(dat);
 177   1      }
 178          /*返回开机次数*/
C51 COMPILER V9.60.7.0   MAIN                                                              09/28/2025 15:09:35 PAGE 4   

 179          unsigned char at24c02_init()
 180          {
 181   1        /*用数码管显示开机次数，模拟i2c另外文件*/
 182   1        unsigned char times;
 183   1        times = read_AT24C02(254);
 184   1        //printf("times=%bu\n",times);
 185   1        if(times < 255 )
 186   1        {
 187   2            times=times+1;
 188   2            write_AT24C02(254,times);
 189   2            delay(130);
 190   2        //  printf("times2=%bu\n",times);
 191   2        }
 192   1        else
 193   1        {
 194   2          times = 1;
 195   2          write_AT24C02(254,times);
 196   2          delay(130);
 197   2          
 198   2        }
 199   1        //printf("times3=%bu\n",times);
 200   1        return times;
 201   1        
 202   1      }
 203          
 204          void AT_Buff()        //转换值送显示缓冲区(BCD码)
 205          {
 206   1        digits[3]= 0;
 207   1        digits[2]= boot_times/100;  //百位
 208   1        digits[1]= (boot_times/10)%10;  //十位
 209   1        digits[0]= boot_times%10;     //个位
 210   1      }
 211          
 212          void DisplayBootTimes()
 213          {
 214   1        unsigned char i;
 215   1        SEG_CHOICE=1;
 216   1        P0=0xff;
 217   1        LED_CHOICE=1;
 218   1        LED_CHOICE=0;
 219   1        for(i=0;i<4;i++)
 220   1        {
 221   2          SEG_CHOICE=1;
 222   2          P0=SegCode[digits[i]];
 223   2          SEG_CHOICE=0;
 224   2          P0=BitCode[i];
 225   2          delay_ADC(10);
 226   2        }
 227   1        SEG_CHOICE = 1;
 228   1        P0 = 0xff;
 229   1        SEG_CHOICE = 0;
 230   1      }
 231          
 232          
 233          /******模数转换******/
 234          unsigned int TLC549_ADC(void)
 235          {
 236   1        unsigned int i,temp=0;
 237   1        CS=1;
 238   1        CLK =0;
 239   1        CS=0;
 240   1        delay_us(20);
C51 COMPILER V9.60.7.0   MAIN                                                              09/28/2025 15:09:35 PAGE 5   

 241   1        for(i=0;i<8;i++)
 242   1        {
 243   2          temp=temp<<1;
 244   2          if (DOUT == 1) temp|=0x01;
 245   2          CLK=1;
 246   2          delay_us(10);
 247   2          CLK =0;
 248   2          delay_us(10);
 249   2        }
 250   1        
 251   1        CS =1;
 252   1        delay_us(100);
 253   1        //printf("%d adc \r\n",temp);
 254   1        return (temp);
 255   1      }
 256          void AD_Buff()        //AD转换值送显示缓冲区(BCD码)
 257          {
 258   1        DispBuf_AD[3]= (unsigned int)Volt /1000;    //千位
 259   1        DispBuf_AD[2]= ((unsigned int)Volt/100)%10; //百位
 260   1        DispBuf_AD[1]= ((unsigned int)Volt /10)%10; //十位
 261   1        DispBuf_AD[0]= (unsigned int)Volt %10;      //个位
 262   1      }
 263          
 264          void adc_display()
 265          {
 266   1        unsigned char i;
 267   1        SEG_CHOICE=1;
 268   1        P0=0xff;
 269   1        LED_CHOICE=1;
 270   1        LED_CHOICE=0;
 271   1        for(i=0;i<4;i++)
 272   1        {
 273   2          if(i==3)
 274   2          {
 275   3            SEG_CHOICE=1;
 276   3            P0=SegCode[DispBuf_AD[i]]&0x7f;
 277   3            SEG_CHOICE=0;
 278   3            P0=BitCode[i];
 279   3            delay(10);
 280   3          }
 281   2          else
 282   2          {
 283   3            SEG_CHOICE=1;
 284   3            P0=SegCode[DispBuf_AD[i]];
 285   3            SEG_CHOICE=0;
 286   3            P0=BitCode[i];
 287   3            delay(10);
 288   3          }
 289   2        }
 290   1        SEG_CHOICE = 1;
 291   1        P0 = 0xff;
 292   1        SEG_CHOICE = 0;
 293   1      }
 294          
 295          
 296          
 297          /******蜂鸣器******/
 298          void Delay_B(unsigned int time)
 299          {
 300   1          unsigned int i;
 301   1          for (i = 0; i < time; i++);
 302   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              09/28/2025 15:09:35 PAGE 6   

 303          
 304          void buzz_running()
 305          {
 306   1          beep=0;
 307   1          Delay_B(30);
 308   1          beep=1;
 309   1          Delay_B(30);
 310   1      }
 311          
 312          void key_check(void)
 313          {
 314   1          // 检查S1按键
 315   1          if (S1 == 0) {
 316   2              delay(10); // 延时去抖动
 317   2              if (S1 == 0 && key_flag != 1) {
 318   3                  key_flag = 1; // 设置S1标志位
 319   3              }
 320   2          }
 321   1      
 322   1          // 检查S2按键
 323   1          if (S2 == 0) {
 324   2              delay(10); // 延时去抖动
 325   2              if (S2 == 0 && key_flag != 2) {
 326   3                  key_flag = 2; // 设置S2标志位
 327   3              }
 328   2          }
 329   1      
 330   1          // 检查S3按键
 331   1          if (S3 == 0) {
 332   2              delay(10); // 延时去抖动
 333   2              if (S3 == 0 && key_flag != 3) {
 334   3                  key_flag = 3; // 设置S3标志位
 335   3              }
 336   2          }
 337   1      
 338   1          // 检查S4按键
 339   1          if (S4 == 0) {
 340   2              delay(10); // 延时去抖动
 341   2              if (S4 == 0 && key_flag != 4) {
 342   3                  key_flag = 4; // 设置S4标志位
 343   3              }
 344   2          }
 345   1      
 346   1          // 如果按键释放，则清除标志位
 347   1          if (S1 && key_flag == 1) key_flag = 0;
 348   1          if (S2 && key_flag == 2) key_flag = 0;
 349   1          if (S3 && key_flag == 3) key_flag = 0;
 350   1          if (S4 && key_flag == 4) key_flag = 0;
 351   1      }
 352          
 353          void process_key_flags(void)
 354          {
 355   1          switch(key_flag) {
 356   2            case 0:
 357   2              break;
 358   2            case 1: // S1按键按下
 359   2            {
 360   3                unsigned char i = 0;
 361   3                unsigned int ad;
 362   3                while((S2&S3&S4) == 1) {
 363   4                    i++;
 364   4                    if(i == 20) {
C51 COMPILER V9.60.7.0   MAIN                                                              09/28/2025 15:09:35 PAGE 7   

 365   5                        ad = TLC549_ADC();
 366   5                        i = 0;
 367   5                    }
 368   4                    Volt = 5.0 * ad / 255.0 * 1000.0;
 369   4                    AD_Buff();
 370   4                    adc_display();
 371   4                }
 372   3                break;
 373   3            }
 374   2            case 2: // S2按键按下
 375   2            {
 376   3                while((S1&S3&S4)  != 0) {
 377   4                    Read_Temp();
 378   4                    Temp_to_Buff();
 379   4                    Display();
 380   4                }
 381   3                break;
 382   3            }
 383   2            case 3: // S3按键按下
 384   2            {
 385   3                buzz_running();
 386   3                break;
 387   3            }
 388   2            case 4: // S4按键按下
 389   2            {
 390   3                while((S1&S2&S3)  != 0) {
 391   4                  DisplayBootTimes();
 392   4                }
 393   3                break;
 394   3            }
 395   2            default:
 396   2                break;
 397   2          }
 398   1      }
 399          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1170    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     28      52
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
